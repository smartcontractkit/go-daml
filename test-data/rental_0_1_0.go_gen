package main

import (
	"errors"
	"fmt"
	"math/big"
	"strings"

	"github.com/smartcontractkit/go-daml/pkg/bind"
	"github.com/smartcontractkit/go-daml/pkg/codec"
	"github.com/smartcontractkit/go-daml/pkg/model"
	. "github.com/smartcontractkit/go-daml/pkg/types"
)

var (
	_ = fmt.Sprintf
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = model.Command{}
	_ bind.BoundTemplate
)

const PackageName = "rental"
const SDKVersion = "1.18.1"

type Template interface {
	CreateCommand() *model.CreateCommand
	GetTemplateID() string
}

func argsToMap(args any) map[string]any {
	if args == nil {
		return map[string]any{}
	}

	if m, ok := args.(map[string]any); ok {
		return m
	}

	type mapper interface {
		ToMap() map[string]any
	}
	if mapper, ok := args.(mapper); ok {
		return mapper.ToMap()
	}

	return map[string]any{"args": args}
}

// Accept is a Record type
type Accept struct {
	Foo TEXT  `json:"foo"`
	Bar INT64 `json:"bar"`
}

// ToMap converts Accept to a map for DAML arguments
func (t Accept) ToMap() map[string]any {
	m := make(map[string]any)

	m["foo"] = string(t.Foo)

	m["bar"] = int64(t.Bar)

	return m
}

func (t Accept) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *Accept) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// RentalAgreement is a Template type
type RentalAgreement struct {
	Landlord PARTY `json:"landlord"`
	Tenant   PARTY `json:"tenant"`
	Terms    TEXT  `json:"terms"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t RentalAgreement) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "Rental", "RentalAgreement")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t RentalAgreement) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "Rental", "RentalAgreement")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t RentalAgreement) CreateCommand() *model.CreateCommand {
	args := make(map[string]any)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["landlord"] = t.Landlord.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["tenant"] = t.Tenant.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["terms"] = string(t.Terms)

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t RentalAgreement) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]any)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["landlord"] = t.Landlord.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["tenant"] = t.Tenant.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["terms"] = string(t.Terms)

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t RentalAgreement) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *RentalAgreement) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for RentalAgreement

// Archive exercises the Archive choice on this RentalAgreement contract
// This method uses the package name in the template ID
func (t RentalAgreement) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Rental", "RentalAgreement"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]any{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t RentalAgreement) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Rental", "RentalAgreement"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]any{},
	}
}

// RentalProposal is a Template type
type RentalProposal struct {
	Landlord PARTY `json:"landlord"`
	Tenant   PARTY `json:"tenant"`
	Terms    TEXT  `json:"terms"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t RentalProposal) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "Rental", "RentalProposal")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t RentalProposal) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "Rental", "RentalProposal")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t RentalProposal) CreateCommand() *model.CreateCommand {
	args := make(map[string]any)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["landlord"] = t.Landlord.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["tenant"] = t.Tenant.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["terms"] = string(t.Terms)

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t RentalProposal) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]any)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["landlord"] = t.Landlord.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["tenant"] = t.Tenant.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["terms"] = string(t.Terms)

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t RentalProposal) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *RentalProposal) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for RentalProposal

// Archive exercises the Archive choice on this RentalProposal contract
// This method uses the package name in the template ID
func (t RentalProposal) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Rental", "RentalProposal"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]any{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t RentalProposal) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Rental", "RentalProposal"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]any{},
	}
}

// Accept exercises the Accept choice on this RentalProposal contract
// This method uses the package name in the template ID
func (t RentalProposal) Accept(contractID string, args Accept) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Rental", "RentalProposal"),
		ContractID: contractID,
		Choice:     "Accept",
		Arguments:  argsToMap(args),
	}
}

// AcceptWithPackageID exercises the Accept choice using the provided package ID instead of package name
func (t RentalProposal) AcceptWithPackageID(contractID string, packageID string, args Accept) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Rental", "RentalProposal"),
		ContractID: contractID,
		Choice:     "Accept",
		Arguments:  argsToMap(args),
	}
}
