package codegen_test

import (
	"errors"
	"fmt"
	"math/big"
	"strings"

	"github.com/smartcontractkit/go-daml/pkg/bind"
	"github.com/smartcontractkit/go-daml/pkg/codec"
	"github.com/smartcontractkit/go-daml/pkg/model"
	. "github.com/smartcontractkit/go-daml/pkg/types"
)

var (
	_ = fmt.Sprintf
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = model.Command{}
	_ bind.BoundTemplate
)

const PackageName = "all-kinds-of"
const SDKVersion = "3.3.0-snapshot.20250417.0"

type Template interface {
	CreateCommand() *model.CreateCommand
	GetTemplateID() string
}

func argsToMap(args interface{}) map[string]interface{} {
	if args == nil {
		return map[string]interface{}{}
	}

	if m, ok := args.(map[string]interface{}); ok {
		return m
	}

	type mapper interface {
		ToMap() map[string]interface{}
	}
	if mapper, ok := args.(mapper); ok {
		return mapper.ToMap()
	}

	return map[string]interface{}{"args": args}
}

// Accept is a Record type
type Accept struct {
}

// ToMap converts Accept to a map for DAML arguments
func (t Accept) ToMap() map[string]interface{} {
	m := make(map[string]interface{})
	return m
}

func (t Accept) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *Accept) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Color is an enum type
type Color string

const (
	ColorRed Color = "Red"

	ColorGreen Color = "Green"

	ColorBlue Color = "Blue"
)

func (e Color) GetEnumConstructor() string { return string(e) }

func (e Color) GetEnumTypeID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "AllKindsOf", "Color")
}

// GetEnumTypeIDWithPackageID returns the enum type ID using the provided package ID instead of package name
func (e Color) GetEnumTypeIDWithPackageID(packageID string) string {
	return fmt.Sprintf("#%s:%s:%s", packageID, "AllKindsOf", "Color")
}

func (e Color) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(e)
}

func (e *Color) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, e)
}

var _ ENUM = Color("")

// MappyContract is a Template type
type MappyContract struct {
	Operator PARTY   `json:"operator"`
	Value    TEXTMAP `json:"value"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t MappyContract) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "AllKindsOf", "MappyContract")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t MappyContract) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "AllKindsOf", "MappyContract")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t MappyContract) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["operator"] = t.Operator.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["value"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Value).(mapper); ok {
			return m.toMap()
		}
		return t.Value
	}()

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t MappyContract) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["operator"] = t.Operator.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["value"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Value).(mapper); ok {
			return m.toMap()
		}
		return t.Value
	}()

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t MappyContract) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *MappyContract) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for MappyContract

// Archive exercises the Archive choice on this MappyContract contract
// This method uses the package name in the template ID
func (t MappyContract) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "AllKindsOf", "MappyContract"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t MappyContract) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "AllKindsOf", "MappyContract"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// MyPair is a Record type
type MyPair struct {
	Left  a `json:"left"`
	Right a `json:"right"`
}

// ToMap converts MyPair to a map for DAML arguments
func (t MyPair) ToMap() map[string]interface{} {
	m := make(map[string]interface{})

	m["left"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Left).(mapper); ok {
			return m.toMap()
		}
		return t.Left
	}()

	m["right"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Right).(mapper); ok {
			return m.toMap()
		}
		return t.Right
	}()

	return m
}

func (t MyPair) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *MyPair) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// OneOfEverything is a Template type
type OneOfEverything struct {
	Operator        PARTY     `json:"operator"`
	SomeBoolean     BOOL      `json:"someBoolean"`
	SomeInteger     INT64     `json:"someInteger"`
	SomeDecimal     NUMERIC   `json:"someDecimal"`
	SomeMaybe       *INT64    `json:"someMaybe"`
	SomeMaybeNot    *INT64    `json:"someMaybeNot"`
	SomeText        TEXT      `json:"someText"`
	SomeDate        DATE      `json:"someDate"`
	SomeDatetime    TIMESTAMP `json:"someDatetime"`
	SomeSimpleList  []INT64   `json:"someSimpleList"`
	SomeSimplePair  MyPair    `json:"someSimplePair"`
	SomeNestedPair  MyPair    `json:"someNestedPair"`
	SomeUglyNesting VPair     `json:"someUglyNesting"`
	SomeMeasurement NUMERIC   `json:"someMeasurement"`
	SomeEnum        Color     `json:"someEnum"`
	TheUnit         UNIT      `json:"theUnit"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t OneOfEverything) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "AllKindsOf", "OneOfEverything")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t OneOfEverything) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "AllKindsOf", "OneOfEverything")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t OneOfEverything) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["operator"] = t.Operator.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someBoolean"] = bool(t.SomeBoolean)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someInteger"] = int64(t.SomeInteger)

	if t.SomeDecimal != "" {
		args["someDecimal"] = t.SomeDecimal
	}

	if t.SomeMaybe != nil {
		args["someMaybe"] = map[string]interface{}{
			"_type": "optional",
			"value": int64(*t.SomeMaybe),
		}
	} else {
		args["someMaybe"] = map[string]interface{}{
			"_type": "optional",
		}
	}

	if t.SomeMaybeNot != nil {
		args["someMaybeNot"] = map[string]interface{}{
			"_type": "optional",
			"value": int64(*t.SomeMaybeNot),
		}
	} else {
		args["someMaybeNot"] = map[string]interface{}{
			"_type": "optional",
		}
	}

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someText"] = string(t.SomeText)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someDate"] = t.SomeDate

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someDatetime"] = t.SomeDatetime

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someSimpleList"] = func() []interface{} {
		res := make([]interface{}, 0, len(t.SomeSimpleList))
		for _, e := range t.SomeSimpleList {
			res = append(res, int64(e))
		}
		return res
	}()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someSimplePair"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.SomeSimplePair).(mapper); ok {
			return m.toMap()
		}
		return t.SomeSimplePair
	}()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someNestedPair"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.SomeNestedPair).(mapper); ok {
			return m.toMap()
		}
		return t.SomeNestedPair
	}()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someUglyNesting"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.SomeUglyNesting).(mapper); ok {
			return m.toMap()
		}
		return t.SomeUglyNesting
	}()

	if t.SomeMeasurement != "" {
		args["someMeasurement"] = t.SomeMeasurement
	}

	if t.SomeEnum != "" {
		args["someEnum"] = func() interface{} {
			type mapper interface{ toMap() map[string]interface{} }
			if m, ok := any(t.SomeEnum).(mapper); ok {
				return m.toMap()
			}
			return t.SomeEnum
		}()
	}

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["theUnit"] = map[string]interface{}{"_type": "unit"}

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t OneOfEverything) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["operator"] = t.Operator.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someBoolean"] = bool(t.SomeBoolean)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someInteger"] = int64(t.SomeInteger)

	if t.SomeDecimal != "" {
		args["someDecimal"] = t.SomeDecimal
	}

	if t.SomeMaybe != nil {
		args["someMaybe"] = map[string]interface{}{
			"_type": "optional",
			"value": int64(*t.SomeMaybe),
		}
	} else {
		args["someMaybe"] = map[string]interface{}{
			"_type": "optional",
		}
	}

	if t.SomeMaybeNot != nil {
		args["someMaybeNot"] = map[string]interface{}{
			"_type": "optional",
			"value": int64(*t.SomeMaybeNot),
		}
	} else {
		args["someMaybeNot"] = map[string]interface{}{
			"_type": "optional",
		}
	}

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someText"] = string(t.SomeText)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someDate"] = t.SomeDate

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someDatetime"] = t.SomeDatetime

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someSimpleList"] = func() []interface{} {
		res := make([]interface{}, 0, len(t.SomeSimpleList))
		for _, e := range t.SomeSimpleList {
			res = append(res, int64(e))
		}
		return res
	}()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someSimplePair"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.SomeSimplePair).(mapper); ok {
			return m.toMap()
		}
		return t.SomeSimplePair
	}()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someNestedPair"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.SomeNestedPair).(mapper); ok {
			return m.toMap()
		}
		return t.SomeNestedPair
	}()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["someUglyNesting"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.SomeUglyNesting).(mapper); ok {
			return m.toMap()
		}
		return t.SomeUglyNesting
	}()

	if t.SomeMeasurement != "" {
		args["someMeasurement"] = t.SomeMeasurement
	}

	if t.SomeEnum != "" {
		args["someEnum"] = func() interface{} {
			type mapper interface{ toMap() map[string]interface{} }
			if m, ok := any(t.SomeEnum).(mapper); ok {
				return m.toMap()
			}
			return t.SomeEnum
		}()
	}

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["theUnit"] = map[string]interface{}{"_type": "unit"}

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t OneOfEverything) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *OneOfEverything) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for OneOfEverything

// Archive exercises the Archive choice on this OneOfEverything contract
// This method uses the package name in the template ID
func (t OneOfEverything) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "AllKindsOf", "OneOfEverything"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t OneOfEverything) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "AllKindsOf", "OneOfEverything"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// Accept exercises the Accept choice on this OneOfEverything contract
// This method uses the package name in the template ID
func (t OneOfEverything) Accept(contractID string, args Accept) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "AllKindsOf", "OneOfEverything"),
		ContractID: contractID,
		Choice:     "Accept",
		Arguments:  argsToMap(args),
	}
}

// AcceptWithPackageID exercises the Accept choice using the provided package ID instead of package name
func (t OneOfEverything) AcceptWithPackageID(contractID string, packageID string, args Accept) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "AllKindsOf", "OneOfEverything"),
		ContractID: contractID,
		Choice:     "Accept",
		Arguments:  argsToMap(args),
	}
}

// VPair is a variant/union type
type VPair struct {
	Left  *a     `json:"Left,omitempty"`
	Right *a     `json:"Right,omitempty"`
	Both  *VPair `json:"Both,omitempty"`
}

// MarshalJSON implements custom JSON marshaling for VPair
func (v VPair) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(v)
}

// UnmarshalJSON implements custom JSON unmarshalling for VPair
func (v *VPair) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, v)
}

// GetVariantTag implements types.VARIANT interface
func (v VPair) GetVariantTag() string {

	if v.Left != nil {
		return "Left"
	}

	if v.Right != nil {
		return "Right"
	}

	if v.Both != nil {
		return "Both"
	}

	return ""
}

// GetVariantValue implements types.VARIANT interface
func (v VPair) GetVariantValue() interface{} {

	if v.Left != nil {
		return v.Left
	}

	if v.Right != nil {
		return v.Right
	}

	if v.Both != nil {
		return v.Both
	}

	return nil
}

var _ VARIANT = (*VPair)(nil)
