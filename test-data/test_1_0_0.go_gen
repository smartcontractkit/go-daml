package main

import (
	"errors"
	"fmt"
	"math/big"
	"strings"

	"github.com/smartcontractkit/go-daml/pkg/bind"
	"github.com/smartcontractkit/go-daml/pkg/codec"
	"github.com/smartcontractkit/go-daml/pkg/model"
	. "github.com/smartcontractkit/go-daml/pkg/types"
)

var (
	_ = fmt.Sprintf
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = model.Command{}
	_ bind.BoundTemplate
)

const PackageName = "test"
const SDKVersion = "2.9.1"

type Template interface {
	CreateCommand() *model.CreateCommand
	GetTemplateID() string
}

func argsToMap(args interface{}) map[string]interface{} {
	if args == nil {
		return map[string]interface{}{}
	}

	if m, ok := args.(map[string]interface{}); ok {
		return m
	}

	type mapper interface {
		ToMap() map[string]interface{}
	}
	if mapper, ok := args.(mapper); ok {
		return mapper.ToMap()
	}

	return map[string]interface{}{"args": args}
}

// Address is a variant/union type
type Address struct {
	US *USAddress `json:"US,omitempty"`
	UK *UKAddress `json:"UK,omitempty"`
}

// MarshalJSON implements custom JSON marshaling for Address
func (v Address) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(v)
}

// UnmarshalJSON implements custom JSON unmarshalling for Address
func (v *Address) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, v)
}

// GetVariantTag implements types.VARIANT interface
func (v Address) GetVariantTag() string {

	if v.US != nil {
		return "US"
	}

	if v.UK != nil {
		return "UK"
	}

	return ""
}

// GetVariantValue implements types.VARIANT interface
func (v Address) GetVariantValue() interface{} {

	if v.US != nil {
		return v.US
	}

	if v.UK != nil {
		return v.UK
	}

	return nil
}

var _ VARIANT = (*Address)(nil)

// American is a Template type
type American struct {
	Person  PARTY     `json:"person"`
	Address USAddress `json:"address"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t American) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "Address", "American")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t American) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "Address", "American")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t American) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["person"] = t.Person.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["address"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Address).(mapper); ok {
			return m.toMap()
		}
		return t.Address
	}()

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t American) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["person"] = t.Person.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["address"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Address).(mapper); ok {
			return m.toMap()
		}
		return t.Address
	}()

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t American) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *American) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for American

// Archive exercises the Archive choice on this American contract
// This method uses the package name in the template ID
func (t American) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Address", "American"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t American) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Address", "American"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// Briton is a Template type
type Briton struct {
	Person  PARTY     `json:"person"`
	Address UKAddress `json:"address"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t Briton) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "Address", "Briton")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t Briton) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "Address", "Briton")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t Briton) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["person"] = t.Person.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["address"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Address).(mapper); ok {
			return m.toMap()
		}
		return t.Address
	}()

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t Briton) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["person"] = t.Person.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["address"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Address).(mapper); ok {
			return m.toMap()
		}
		return t.Address
	}()

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t Briton) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *Briton) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for Briton

// Archive exercises the Archive choice on this Briton contract
// This method uses the package name in the template ID
func (t Briton) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Address", "Briton"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t Briton) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Address", "Briton"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// OptionalFields is a Template type
type OptionalFields struct {
	Party  PARTY    `json:"party"`
	AMaybe OPTIONAL `json:"aMaybe"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t OptionalFields) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "Primitives", "OptionalFields")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t OptionalFields) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "Primitives", "OptionalFields")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t OptionalFields) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["party"] = t.Party.ToMap()

	if t.AMaybe != nil {
		args["aMaybe"] = map[string]interface{}{
			"_type": "optional",
			"value": *t.AMaybe,
		}
	} else {
		args["aMaybe"] = map[string]interface{}{
			"_type": "optional",
		}
	}

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t OptionalFields) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["party"] = t.Party.ToMap()

	if t.AMaybe != nil {
		args["aMaybe"] = map[string]interface{}{
			"_type": "optional",
			"value": *t.AMaybe,
		}
	} else {
		args["aMaybe"] = map[string]interface{}{
			"_type": "optional",
		}
	}

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t OptionalFields) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *OptionalFields) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for OptionalFields

// Archive exercises the Archive choice on this OptionalFields contract
// This method uses the package name in the template ID
func (t OptionalFields) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Primitives", "OptionalFields"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t OptionalFields) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Primitives", "OptionalFields"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// OptionalFieldsCleanUp exercises the OptionalFieldsCleanUp choice on this OptionalFields contract
// This method uses the package name in the template ID
func (t OptionalFields) OptionalFieldsCleanUp(contractID string, args OptionalFieldsCleanUp) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Primitives", "OptionalFields"),
		ContractID: contractID,
		Choice:     "OptionalFieldsCleanUp",
		Arguments:  argsToMap(args),
	}
}

// OptionalFieldsCleanUpWithPackageID exercises the OptionalFieldsCleanUp choice using the provided package ID instead of package name
func (t OptionalFields) OptionalFieldsCleanUpWithPackageID(contractID string, packageID string, args OptionalFieldsCleanUp) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Primitives", "OptionalFields"),
		ContractID: contractID,
		Choice:     "OptionalFieldsCleanUp",
		Arguments:  argsToMap(args),
	}
}

// OptionalFieldsCleanUp is a Record type
type OptionalFieldsCleanUp struct {
}

// ToMap converts OptionalFieldsCleanUp to a map for DAML arguments
func (t OptionalFieldsCleanUp) ToMap() map[string]interface{} {
	m := make(map[string]interface{})
	return m
}

func (t OptionalFieldsCleanUp) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *OptionalFieldsCleanUp) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Person is a Template type
type Person struct {
	Person  PARTY   `json:"person"`
	Address Address `json:"address"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t Person) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "Address", "Person")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t Person) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "Address", "Person")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t Person) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["person"] = t.Person.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["address"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Address).(mapper); ok {
			return m.toMap()
		}
		return t.Address
	}()

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t Person) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["person"] = t.Person.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["address"] = func() interface{} {
		type mapper interface{ toMap() map[string]interface{} }
		if m, ok := any(t.Address).(mapper); ok {
			return m.toMap()
		}
		return t.Address
	}()

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t Person) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *Person) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for Person

// Archive exercises the Archive choice on this Person contract
// This method uses the package name in the template ID
func (t Person) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Address", "Person"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t Person) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Address", "Person"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// SimpleFields is a Template type
type SimpleFields struct {
	Party     PARTY     `json:"party"`
	ABool     BOOL      `json:"aBool"`
	AInt      INT64     `json:"aInt"`
	ADecimal  NUMERIC   `json:"aDecimal"`
	AText     TEXT      `json:"aText"`
	ADate     DATE      `json:"aDate"`
	ADatetime TIMESTAMP `json:"aDatetime"`
}

// GetTemplateID returns the template ID for this template using the package name
func (t SimpleFields) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "Primitives", "SimpleFields")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t SimpleFields) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "Primitives", "SimpleFields")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t SimpleFields) CreateCommand() *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["party"] = t.Party.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aBool"] = bool(t.ABool)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aInt"] = int64(t.AInt)

	if t.ADecimal != "" {
		args["aDecimal"] = t.ADecimal
	}

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aText"] = string(t.AText)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aDate"] = t.ADate

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aDatetime"] = t.ADatetime

	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t SimpleFields) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]interface{})

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["party"] = t.Party.ToMap()

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aBool"] = bool(t.ABool)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aInt"] = int64(t.AInt)

	if t.ADecimal != "" {
		args["aDecimal"] = t.ADecimal
	}

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aText"] = string(t.AText)

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aDate"] = t.ADate

	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["aDatetime"] = t.ADatetime

	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

func (t SimpleFields) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *SimpleFields) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// Choice methods for SimpleFields

// SimpleFieldsCleanUp exercises the SimpleFieldsCleanUp choice on this SimpleFields contract
// This method uses the package name in the template ID
func (t SimpleFields) SimpleFieldsCleanUp(contractID string, args SimpleFieldsCleanUp) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Primitives", "SimpleFields"),
		ContractID: contractID,
		Choice:     "SimpleFieldsCleanUp",
		Arguments:  argsToMap(args),
	}
}

// SimpleFieldsCleanUpWithPackageID exercises the SimpleFieldsCleanUp choice using the provided package ID instead of package name
func (t SimpleFields) SimpleFieldsCleanUpWithPackageID(contractID string, packageID string, args SimpleFieldsCleanUp) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Primitives", "SimpleFields"),
		ContractID: contractID,
		Choice:     "SimpleFieldsCleanUp",
		Arguments:  argsToMap(args),
	}
}

// Archive exercises the Archive choice on this SimpleFields contract
// This method uses the package name in the template ID
func (t SimpleFields) Archive(contractID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "Primitives", "SimpleFields"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// ArchiveWithPackageID exercises the Archive choice using the provided package ID instead of package name
func (t SimpleFields) ArchiveWithPackageID(contractID string, packageID string) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "Primitives", "SimpleFields"),
		ContractID: contractID,
		Choice:     "Archive",
		Arguments:  map[string]interface{}{},
	}
}

// SimpleFieldsCleanUp is a Record type
type SimpleFieldsCleanUp struct {
}

// ToMap converts SimpleFieldsCleanUp to a map for DAML arguments
func (t SimpleFieldsCleanUp) ToMap() map[string]interface{} {
	m := make(map[string]interface{})
	return m
}

func (t SimpleFieldsCleanUp) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *SimpleFieldsCleanUp) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// UKAddress is a Record type
type UKAddress struct {
	Address  LIST     `json:"address"`
	Locality OPTIONAL `json:"locality"`
	City     TEXT     `json:"city"`
	State    TEXT     `json:"state"`
	Postcode TEXT     `json:"postcode"`
}

// ToMap converts UKAddress to a map for DAML arguments
func (t UKAddress) ToMap() map[string]interface{} {
	m := make(map[string]interface{})

	m["address"] = t.Address

	m["locality"] = t.Locality

	m["city"] = string(t.City)

	m["state"] = string(t.State)

	m["postcode"] = string(t.Postcode)

	return m
}

func (t UKAddress) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *UKAddress) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}

// USAddress is a Record type
type USAddress struct {
	Address LIST  `json:"address"`
	City    TEXT  `json:"city"`
	State   TEXT  `json:"state"`
	Zip     INT64 `json:"zip"`
}

// ToMap converts USAddress to a map for DAML arguments
func (t USAddress) ToMap() map[string]interface{} {
	m := make(map[string]interface{})

	m["address"] = t.Address

	m["city"] = string(t.City)

	m["state"] = string(t.State)

	m["zip"] = int64(t.Zip)

	return m
}

func (t USAddress) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshall(t)
}

func (t *USAddress) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshall(data, t)
}
