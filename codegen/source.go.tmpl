{{- /*gotype: github.com/smartcontractkit/go-daml/codegen.tmplData*/ -}}
package {{.Package}}

import (
	"fmt"
	"math/big"
	"strings"
	"errors"

	"github.com/smartcontractkit/go-daml/pkg/bind"
	"github.com/smartcontractkit/go-daml/pkg/model"
	"github.com/smartcontractkit/go-daml/pkg/types"
	"github.com/smartcontractkit/go-daml/pkg/codec"

	{{- range .ImportedPackages}}
	{{.Alias}} "{{.Import}}"
	{{- end}}
)

var (
	_ = fmt.Sprintf
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = model.Command{}
	_ bind.BoundTemplate
)


{{define "fieldToDAMLValue"}}
{{- if .IsOptional -}}
  {{$baseType := stringsTrimPrefix .Type.GoType "*"}}
  {{- if eq $baseType "types.INT64" -}}int64(*t.{{capitalise .Name}})
  {{- else if eq $baseType "types.TEXT" -}}string(*t.{{capitalise .Name}})
  {{- else if eq $baseType "types.BOOL" -}}bool(*t.{{capitalise .Name}})
  {{- else if eq $baseType "types.PARTY" -}}(*t.{{capitalise .Name}}).ToMap()
  {{- else if eq $baseType "types.NUMERIC" -}}*t.{{capitalise .Name}}
  {{- else if eq $baseType "types.DECIMAL" -}}(*big.Int)(*t.{{capitalise .Name}})
  {{- else if eq $baseType "types.DATE" -}}*t.{{capitalise .Name}}
  {{- else if eq $baseType "types.TIMESTAMP" -}}*t.{{capitalise .Name}}
  {{- else if eq $baseType "types.UNIT" -}}map[string]any{"_type": "unit"}
  {{- else -}}*t.{{capitalise .Name}}
  {{- end -}}
{{- else -}}
  {{- if eq .Type.GoType "types.PARTY" -}}t.{{capitalise .Name}}.ToMap()
  {{- else if eq .Type.GoType "types.TEXT" -}}string(t.{{capitalise .Name}})
  {{- else if eq .Type.GoType "types.INT64" -}}int64(t.{{capitalise .Name}})
  {{- else if eq .Type.GoType "types.BOOL" -}}bool(t.{{capitalise .Name}})
  {{- else if eq .Type.GoType "types.NUMERIC" -}}t.{{capitalise .Name}}
  {{- else if eq .Type.GoType "types.DECIMAL" -}}(*big.Int)(t.{{capitalise .Name}})
  {{- else if eq .Type.GoType "types.DATE" -}}t.{{capitalise .Name}}
  {{- else if eq .Type.GoType "types.TIMESTAMP" -}}t.{{capitalise .Name}}
  {{- else if eq .Type.GoType "types.UNIT" -}}map[string]any{"_type": "unit"}

  {{- else if stringsHasPrefix .Type.GoType "[]" -}}
    func() []any {
      res := make([]any, 0, len(t.{{capitalise .Name}}))
      for _, e := range t.{{capitalise .Name}} {
        {{$elem := stringsTrimPrefix .Type.GoType "[]"}}
        {{- if eq $elem "types.PARTY" -}}
          res = append(res, e.ToMap())
        {{- else if eq $elem "types.TEXT" -}}
          res = append(res, string(e))
        {{- else if eq $elem "types.INT64" -}}
          res = append(res, int64(e))
        {{- else if eq $elem "types.BOOL" -}}
          res = append(res, bool(e))
        {{- else if eq $elem "types.CONTRACT_ID" -}}
          res = append(res, e)
        {{- else if eq $elem "types.NUMERIC" -}}
          res = append(res, e)
        {{- else if eq $elem "types.DECIMAL" -}}
          res = append(res, (*big.Int)(e))
        {{- else -}}
          type mapper interface{ toMap() map[string]any }
          if m, ok := any(e).(mapper); ok {
            res = append(res, m.toMap())
          } else {
            res = append(res, e)
          }
        {{- end -}}
      }
      return res
    }()

  {{- else if eq .Type.GoType "types.LIST" -}}t.{{capitalise .Name}}

  {{- else if eq .Type.GoType "types.GENMAP" -}}
    func() any {
      if t.{{capitalise .Name}} == nil {
        return map[string]any{"_type": "genmap", "value": GENMAP{}}
      }
      return map[string]any{"_type": "genmap", "value": t.{{capitalise .Name}}}
    }()

  {{- else if eq .Type.GoType "types.MAP" -}}t.{{capitalise .Name}}
  {{- else if eq .Type.GoType "types.OPTIONAL" -}}t.{{capitalise .Name}}
  {{- else if eq .Type.GoType "string" -}}string(t.{{capitalise .Name}})
  {{- else -}}
    func() any {
      type mapper interface{ toMap() map[string]any }
      if m, ok := any(t.{{capitalise .Name}}).(mapper); ok {
        return m.toMap()
      }
      return t.{{capitalise .Name}}
    }()
  {{- end -}}
{{- end -}}
{{end}}

{{define "fieldIsNotEmpty"}}
{{- if eq .Type.GoType "types.PARTY" -}}t.{{capitalise .Name}} != ""
{{- else if eq .Type.GoType "types.TEXT" -}}t.{{capitalise .Name}} != ""
{{- else if eq .Type.GoType "types.INT64" -}}t.{{capitalise .Name}} != 0
{{- else if eq .Type.GoType "types.BOOL" -}}true
{{- else if eq .Type.GoType "types.NUMERIC" -}}t.{{capitalise .Name}} != ""
{{- else if eq .Type.GoType "types.DECIMAL" -}}t.{{capitalise .Name}} != nil
{{- else if eq .Type.GoType "types.DATE" -}}!t.{{capitalise .Name}}.IsZero()
{{- else if eq .Type.GoType "types.TIMESTAMP" -}}!t.{{capitalise .Name}}.IsZero()
{{- else if eq .Type.GoType "types.LIST" -}}len(t.{{capitalise .Name}}) > 0
{{- else if stringsHasPrefix .Type.GoType "[]" -}}len(t.{{capitalise .Name}}) > 0
{{- else if eq .Type.GoType "types.GENMAP" -}}t.{{capitalise .Name}} != nil && len(t.{{capitalise .Name}}) > 0
{{- else if eq .Type.GoType "types.MAP" -}}t.{{capitalise .Name}} != nil && len(t.{{capitalise .Name}}) > 0
{{- else if eq .Type.GoType "types.OPTIONAL" -}}t.{{capitalise .Name}} != nil
{{- else if .IsOptional -}}t.{{capitalise .Name}} != nil
{{- else if .IsEnum -}}t.{{capitalise .Name}} != ""
{{- else -}}
  func() any {
    type mapper interface{ toMap() map[string]any }
    if m, ok := any(t.{{capitalise .Name}}).(mapper); ok {
      return m.toMap()
    }
    return t.{{capitalise .Name}}
  }()
{{- end -}}
{{end}}

{{/* ---------------------------------------------------------
   Main package constants / interfaces
   --------------------------------------------------------- */}}

{{if .IsMainDalf}}
const PackageName = "{{.PackageName}}"
const SDKVersion = "{{.SdkVersion}}"

type Template interface {
	CreateCommand() *model.CreateCommand
	GetTemplateID() string
}
{{end}}

{{$structs := .Structs}}
{{range $structs}}
{{if .IsInterface}}
// {{capitalise .Name}} is a DAML interface
type {{capitalise .Name}} interface {
	{{range $choice := .Choices}}
	// {{capitalise $choice.Name}} executes the {{$choice.Name}} choice
	{{capitalise $choice.Name}}(contractID string{{if and (ne $choice.ArgType.GoType "types.UNIT") (ne $choice.ArgType.GoType "")}}, args {{$choice.ArgType.GoType}}{{end}}) *model.ExerciseCommand
	{{end}}
}
{{end}}
{{end}}

{{if .IsMainDalf}}
func argsToMap(args any) map[string]any {
	if args == nil {
		return map[string]any{}
	}

	if m, ok := args.(map[string]any); ok {
		return m
	}

	type mapper interface {
		ToMap() map[string]any
	}
	if mapper, ok := args.(mapper); ok {
		return mapper.ToMap()
	}

	return map[string]any{"args": args}
}
{{end}}

{{/* ---------------------------------------------------------
   Structs / templates / choices generation
   --------------------------------------------------------- */}}

{{$structs2 := .Structs}}
{{range $structs2}}
{{if not .IsInterface}}

{{if eq .RawType "Variant"}}
// {{capitalise .Name}} is a variant/union type
type {{capitalise .Name}} struct {
	{{- range $field := .Fields}}
	{{capitalise $field.Name}} *{{$field.Type.GoType}} `json:"{{$field.Name}},omitempty"`
	{{- end}}
}

// MarshalJSON implements custom JSON marshaling for {{capitalise .Name}}
func (v {{capitalise .Name}}) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshal(v)
}

// UnmarshalJSON implements custom JSON unmarshalling for {{capitalise .Name}}
func (v *{{capitalise .Name}}) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshal(data, v)
}

{{if $.GenerateHexCodec}}
// MarshalHex encodes {{capitalise .Name}} to hex string (Canton MCMS format)
func (v {{capitalise .Name}}) MarshalHex() (string, error) {
	hexCodec := codec.NewHexCodec()
	return hexCodec.Marshal(v)
}

// UnmarshalHex decodes {{capitalise .Name}} from hex string (Canton MCMS format)
func (v *{{capitalise .Name}}) UnmarshalHex(data string) error {
	hexCodec := codec.NewHexCodec()
	return hexCodec.Unmarshal(data, v)
}
{{end}}

// GetVariantTag implements types.VARIANT interface
func (v {{capitalise .Name}}) GetVariantTag() string {
	{{range $field := .Fields}}
	if v.{{capitalise $field.Name}} != nil {
		return "{{$field.Name}}"
	}
	{{end}}
	return ""
}

// GetVariantValue implements types.VARIANT interface
func (v {{capitalise .Name}}) GetVariantValue() any {
	{{range $field := .Fields}}
	if v.{{capitalise $field.Name}} != nil {
		return v.{{capitalise $field.Name}}
	}
	{{end}}
	return nil
}

var _ types.VARIANT = (*{{capitalise .Name}})(nil)

{{else if eq .RawType "Enum"}}
// {{capitalise .Name}} is an enum type
type {{capitalise .Name}} string

const (
	{{$structName := .Name}}{{range $field := .Fields}}
	{{capitalise $structName}}{{$field.Name}} {{capitalise $structName}} = "{{$field.Name}}"
	{{end}}
)

func (e {{capitalise .Name}}) GetEnumConstructor() string { return string(e) }

func (e {{capitalise .Name}}) GetEnumTypeID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "{{.ModuleName}}", "{{capitalise .Name}}")
}

// GetEnumTypeIDWithPackageID returns the enum type ID using the provided package ID instead of package name
func (e {{capitalise .Name}}) GetEnumTypeIDWithPackageID(packageID string) string {
	return fmt.Sprintf("#%s:%s:%s", packageID, "{{.ModuleName}}", "{{capitalise .Name}}")
}

func (e {{capitalise .Name}}) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshal(e)
}

func (e *{{capitalise .Name}}) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshal(data, e)
}

{{if $.GenerateHexCodec}}
// MarshalHex encodes {{capitalise .Name}} to hex string (Canton MCMS format)
func (e {{capitalise .Name}}) MarshalHex() (string, error) {
	hexCodec := codec.NewHexCodec()
	return hexCodec.Marshal(e)
}

// UnmarshalHex decodes {{capitalise .Name}} from hex string (Canton MCMS format)
func (e *{{capitalise .Name}}) UnmarshalHex(data string) error {
	hexCodec := codec.NewHexCodec()
	return hexCodec.Unmarshal(data, e)
}
{{end}}

var _ types.ENUM = {{capitalise .Name}}("")

{{else}}
// {{capitalise .Name}} is a {{.RawType}} type
type {{capitalise .Name}} struct {
	{{- range $field := .Fields}}
	{{capitalise $field.Name}} {{$field.Type.GoType}} `json:"{{$field.Name}}"`
	{{- end}}
}

{{if and (eq .RawType "Record") (not .IsTemplate) (not .IsInterface)}}
// ToMap converts {{capitalise .Name}} to a map for DAML arguments
func (t {{capitalise .Name}}) ToMap() map[string]any {
	m := make(map[string]any)
	{{- range $field := .Fields}}
	{{if $field.IsOptional}}
	if t.{{capitalise $field.Name}} != nil {
		m["{{$field.Name}}"] = map[string]any{
			"_type": "optional",
			"value": {{template "fieldToDAMLValue" $field}},
		}
	} else {
		m["{{$field.Name}}"] = map[string]any{
			"_type": "optional",
		}
	}
	{{else}}
	m["{{$field.Name}}"] = {{template "fieldToDAMLValue" $field}}
	{{end}}
	{{- end}}
	return m
}

func (t {{capitalise .Name}}) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshal(t)
}

func (t *{{capitalise .Name}}) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshal(data, t)
}

{{if $.GenerateHexCodec}}
// MarshalHex encodes {{capitalise .Name}} to hex string (Canton MCMS format)
func (t {{capitalise .Name}}) MarshalHex() (string, error) {
	hexCodec := codec.NewHexCodec()
	return hexCodec.Marshal(t)
}

// UnmarshalHex decodes {{capitalise .Name}} from hex string (Canton MCMS format)
func (t *{{capitalise .Name}}) UnmarshalHex(data string) error {
	hexCodec := codec.NewHexCodec()
	return hexCodec.Unmarshal(data, t)
}
{{end}}
{{end}}

{{if .IsTemplate}}
// GetTemplateID returns the template ID for this template using the package name
func (t {{capitalise .Name}}) GetTemplateID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "{{.ModuleName}}", "{{capitalise .Name}}")
}

// GetTemplateIDWithPackageID returns the template ID using the provided package ID instead of package name
func (t {{capitalise .Name}}) GetTemplateIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "{{.ModuleName}}", "{{capitalise .Name}}")
}

// CreateCommand returns a CreateCommand for this template using the package name
func (t {{capitalise .Name}}) CreateCommand() *model.CreateCommand {
	args := make(map[string]any)
	{{- range $field := .Fields}}
	{{if $field.IsOptional}}
	if t.{{capitalise $field.Name}} != nil {
		args["{{$field.Name}}"] = map[string]any{
			"_type": "optional",
			"value": {{template "fieldToDAMLValue" $field}},
		}
	} else {
		args["{{$field.Name}}"] = map[string]any{
			"_type": "optional",
		}
	}
	{{else if or $field.IsEnum (eq $field.Type.GoType "types.NUMERIC") (eq $field.Type.GoType "types.DECIMAL")}}
	if {{template "fieldIsNotEmpty" $field}} {
		args["{{$field.Name}}"] = {{template "fieldToDAMLValue" $field}}
	}
	{{else}}
	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["{{$field.Name}}"] = {{template "fieldToDAMLValue" $field}}
	{{end}}
	{{- end}}
	return &model.CreateCommand{
		TemplateID: t.GetTemplateID(),
		Arguments:  args,
	}
}

// CreateCommandWithPackageID returns a CreateCommand using the provided package ID instead of package name
func (t {{capitalise .Name}}) CreateCommandWithPackageID(packageID string) *model.CreateCommand {
	args := make(map[string]any)
	{{- range $field := .Fields}}
	{{if $field.IsOptional}}
	if t.{{capitalise $field.Name}} != nil {
		args["{{$field.Name}}"] = map[string]any{
			"_type": "optional",
			"value": {{template "fieldToDAMLValue" $field}},
		}
	} else {
		args["{{$field.Name}}"] = map[string]any{
			"_type": "optional",
		}
	}
	{{else if or $field.IsEnum (eq $field.Type.GoType "types.NUMERIC") (eq $field.Type.GoType "types.DECIMAL")}}
	if {{template "fieldIsNotEmpty" $field}} {
		args["{{$field.Name}}"] = {{template "fieldToDAMLValue" $field}}
	}
	{{else}}
	// IMPORTANT: always include non-optional fields (GENMAP/MAP/LIST/[] etc), even if empty
	args["{{$field.Name}}"] = {{template "fieldToDAMLValue" $field}}
	{{end}}
	{{- end}}
	return &model.CreateCommand{
		TemplateID: t.GetTemplateIDWithPackageID(packageID),
		Arguments:  args,
	}
}

{{if .Key}}
// GetKey returns the key for this template as a string
func (t {{capitalise .Name}}) GetKey() string {
	{{if eq .Key.Type.GoType "types.TEXT"}}
	return string(t.{{capitalise .Key.Name}})
	{{else if eq .Key.Type.GoType "types.PARTY"}}
	return string(t.{{capitalise .Key.Name}})
	{{else if eq .Key.Type.GoType "types.INT64"}}
	return fmt.Sprintf("%d", t.{{capitalise .Key.Name}})
	{{else}}
	return fmt.Sprintf("%v", t.{{capitalise .Key.Name}})
	{{end}}
}
{{end}}

func (t {{capitalise .Name}}) MarshalJSON() ([]byte, error) {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Marshal(t)
}

func (t *{{capitalise .Name}}) UnmarshalJSON(data []byte) error {
	jsonCodec := codec.NewJsonCodec()
	return jsonCodec.Unmarshal(data, t)
}

{{if $.GenerateHexCodec}}
// MarshalHex encodes {{capitalise .Name}} to hex string (Canton MCMS format)
func (t {{capitalise .Name}}) MarshalHex() (string, error) {
	hexCodec := codec.NewHexCodec()
	return hexCodec.Marshal(t)
}

// UnmarshalHex decodes {{capitalise .Name}} from hex string (Canton MCMS format)
func (t *{{capitalise .Name}}) UnmarshalHex(data string) error {
	hexCodec := codec.NewHexCodec()
	return hexCodec.Unmarshal(data, t)
}
{{end}}
{{end}}

{{if and .IsTemplate .Choices}}
{{$templateName := .Name}}
{{$moduleName := .ModuleName}}

// Choice methods for {{capitalise $templateName}}
{{range $choice := .Choices}}
{{$argType := $choice.ArgType.GoType}}
{{- if eq $argType "types.SET" -}}
  {{$argType = capitalise $choice.Name}}
{{- end -}}

// {{capitalise $choice.Name}} exercises the {{$choice.Name}} choice on this {{capitalise $templateName}} contract{{if ne $choice.InterfaceName ""}} via the {{capitalise $choice.InterfaceName}} interface{{end}}
// This method uses the package name in the template ID
func (t {{capitalise $templateName}}) {{capitalise $choice.Name}}(contractID string{{if and (ne $argType "types.UNIT") (ne $argType "")}}, args {{$argType}}{{end}}) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		{{- if ne $choice.InterfaceName ""}}
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "{{$moduleName}}", "{{capitalise $choice.InterfaceDAMLName}}"),
		{{- else}}
		TemplateID: fmt.Sprintf("#%s:%s:%s", PackageName, "{{$moduleName}}", "{{capitalise $templateName}}"),
		{{- end}}
		ContractID: contractID,
		Choice:     "{{$choice.Name}}",
		{{- if and (ne $argType "types.UNIT") (ne $argType "")}}
		Arguments: argsToMap(args),
		{{- else}}
		Arguments: map[string]any{},
		{{- end}}
	}
}

// {{capitalise $choice.Name}}WithPackageID exercises the {{$choice.Name}} choice using the provided package ID instead of package name
func (t {{capitalise $templateName}}) {{capitalise $choice.Name}}WithPackageID(contractID string, packageID string{{if and (ne $argType "types.UNIT") (ne $argType "")}}, args {{$argType}}{{end}}) *model.ExerciseCommand {
	return &model.ExerciseCommand{
		{{- if ne $choice.InterfaceName ""}}
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "{{$moduleName}}", "{{capitalise $choice.InterfaceDAMLName}}"),
		{{- else}}
		TemplateID: fmt.Sprintf("#%s:%s:%s", packageID, "{{$moduleName}}", "{{capitalise $templateName}}"),
		{{- end}}
		ContractID: contractID,
		Choice:     "{{$choice.Name}}",
		{{- if and (ne $argType "types.UNIT") (ne $argType "")}}
		Arguments: argsToMap(args),
		{{- else}}
		Arguments: map[string]any{},
		{{- end}}
	}
}
{{end}}
{{end}}


{{if and .IsTemplate .Implements}}
{{$templateName2 := .Name}}
// Verify interface implementations for {{capitalise .Name}}
{{range $interface := .Implements}}
var _ {{$interface.GoType}} = (*{{capitalise $templateName2}})(nil)
{{end}}
{{end}}

{{end}} {{/* end record/enum/variant */}}
{{end}} {{/* end not interface */}}
{{end}} {{/* end range structs */}}

{{/* ---------------------------------------------------------
   Interface IDs helper funcs
   --------------------------------------------------------- */}}

{{$structs3 := .Structs}}
{{range $structs3}}
{{if .IsInterface}}
{{$interfaceName := .Name}}
{{$damlName := .DAMLName}}
{{$moduleName := .ModuleName}}

// {{capitalise $interfaceName}}InterfaceID returns the interface ID for the {{capitalise $interfaceName}} interface using the package name
func {{capitalise $interfaceName}}InterfaceID() string {
	return fmt.Sprintf("#%s:%s:%s", PackageName, "{{$moduleName}}", "{{capitalise $damlName}}")
}

// {{capitalise $interfaceName}}InterfaceIDWithPackageID returns the interface ID using the provided package ID instead of package name
func {{capitalise $interfaceName}}InterfaceIDWithPackageID(packageID string) string {
	return fmt.Sprintf("%s:%s:%s", packageID, "{{$moduleName}}", "{{capitalise $damlName}}")
}
{{end}}
{{end}}

{{/* ---------------------------------------------------------
   Encoder generation for choice argument types
   --------------------------------------------------------- */}}

{{if and .IsMainDalf .GenerateHexCodec}}
{{$structs4 := .Structs}}
{{$choiceArgTypes := .ChoiceArgTypes}}
// MCMSEncoder interface for typed encoding methods.
// Implemented by Encoder for method-based encoding.
type MCMSEncoder interface {
{{- range $structs4}}
{{- $isChoiceArgType := index $choiceArgTypes .Name}}
{{- $isParamsType := stringsHasSuffix .Name "Params"}}
{{- $baseNameForParams := stringsTrimSuffix .Name "Params"}}
{{- $hasCorrespondingChoiceArgType := and $isParamsType (index $choiceArgTypes $baseNameForParams)}}
{{- if and (not .IsInterface) (not .IsTemplate) (eq .RawType "Record") (or $isChoiceArgType $isParamsType)}}
{{- if not $hasCorrespondingChoiceArgType}}
{{- $hasParamsSuffix := stringsHasSuffix .Name "Params"}}
{{- $methodName := .Name}}
{{- if $hasParamsSuffix}}{{$methodName = stringsTrimSuffix (capitalise .Name) "Params"}}{{else}}{{$methodName = capitalise .Name}}{{end}}
	{{$methodName}}(args {{capitalise .Name}}) (*bind.EncodedChoice, error)
{{- end}}
{{- end}}
{{- end}}
}

// encoder provides typed encoding methods for choice parameters (unexported).
// It wraps bind.BoundTemplate to encode parameters to hex-encoded operation data.
type encoder struct {
	*bind.BoundTemplate
}

// Contract wraps template operations with Sui-style API access.
// Use NewContract to create instances, then call Encoder() for encoding methods.
type Contract struct {
	enc *encoder
}

// NewContract creates a Contract with encoder for the given template.
// This provides Sui-style API: contract.Encoder().Method(args)
func NewContract(packageID, moduleName, templateName string) *Contract {
	return &Contract{
		enc: &encoder{
			BoundTemplate: bind.NewBoundTemplate(packageID, moduleName, templateName),
		},
	}
}

// Encoder returns the encoder for Sui-style contract.Encoder().Method() usage.
func (c *Contract) Encoder() MCMSEncoder {
	return c.enc
}

{{range $structs4}}
{{- /* Only generate encoder methods, no standalone Encode functions */}}
{{- $isChoiceArgType := index $choiceArgTypes .Name}}
{{- $isParamsType := stringsHasSuffix .Name "Params"}}
{{- $baseNameForParams := stringsTrimSuffix .Name "Params"}}
{{- $hasCorrespondingChoiceArgType := and $isParamsType (index $choiceArgTypes $baseNameForParams)}}
{{- if and (not .IsInterface) (not .IsTemplate) (eq .RawType "Record") (or $isChoiceArgType $isParamsType)}}
{{- if not $hasCorrespondingChoiceArgType}}
{{- $hasParamsSuffix := stringsHasSuffix .Name "Params"}}
{{- $methodName := .Name}}
{{- if $hasParamsSuffix}}{{$methodName = stringsTrimSuffix (capitalise .Name) "Params"}}{{else}}{{$methodName = capitalise .Name}}{{end}}
{{- $choiceName := $methodName}}

// {{$methodName}} encodes parameters for the {{$choiceName}} choice.
func (e *encoder) {{$methodName}}(args {{capitalise .Name}}) (*bind.EncodedChoice, error) {
	return e.EncodeChoiceArgs("{{$choiceName}}", args)
}
{{- end}}
{{- end}}
{{- end}}

// Verify MCMSEncoder interface implementation
var _ MCMSEncoder = (*encoder)(nil)
{{end}}
